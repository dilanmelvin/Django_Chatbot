import requests
import json
import logging
from django.conf import settings
from django.shortcuts import render
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from django.views.decorators.http import require_POST
from .models import ChatMessage

# Set up logging
logger = logging.getLogger(__name__)


def chatbot_view(request):
    """Render the main chatbot page"""
    return render(request, 'chatbot/index.html')


@csrf_exempt
@require_POST
def send_message(request):
    """Handle sending messages to Gemini and returning responses"""
    try:
        # Parse the request data
        data = json.loads(request.body)
        user_message = data.get('message', '').strip()
        
        if not user_message:
            return JsonResponse({'error': 'Message cannot be empty'}, status=400)
        
        # Check if Gemini API key is configured
        if not settings.GEMINI_API_KEY:
            return JsonResponse({
                'error': 'Gemini API key not configured. Please set GEMINI_API_KEY in your .env file.'
            }, status=500)
        
        # Log the API key (first few characters only for security)
        logger.info(f"Using Gemini API key starting with: {settings.GEMINI_API_KEY[:10]}...")
        
        # Send message to Gemini using direct HTTP request
        try:
            logger.info(f"Sending message to Gemini: {user_message[:50]}...")
            
            url = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key={settings.GEMINI_API_KEY}"
            
            headers = {
                "Content-Type": "application/json"
            }
            
            payload = {
                "contents": [
                    {
                        "parts": [
                            {
                                "text": f"You are a helpful assistant. Please respond to: {user_message}"
                            }
                        ]
                    }
                ],
                "generationConfig": {
                    "temperature": 0.7,
                    "maxOutputTokens": 500,
                    "topP": 0.8,
                    "topK": 10
                }
            }
            
            response = requests.post(url, headers=headers, json=payload, timeout=30)
            
            if response.status_code == 200:
                response_data = response.json()
                logger.info(f"Gemini response data: {response_data}")
                
                # Extract the response text from Gemini's response structure
                if 'candidates' in response_data and len(response_data['candidates']) > 0:
                    candidate = response_data['candidates'][0]
                    if 'content' in candidate and 'parts' in candidate['content']:
                        bot_response = candidate['content']['parts'][0]['text']
                        logger.info(f"Received response from Gemini: {bot_response[:50]}...")
                        
                        # Save to database
                        try:
                            chat_message = ChatMessage.objects.create(
                                user_message=user_message,
                                bot_response=bot_response
                            )
                            logger.info(f"Saved chat message to database with ID: {chat_message.id}")
                        except Exception as db_error:
                            logger.error(f"Failed to save to database: {str(db_error)}")
                            # Continue anyway, we can still return the response
                        
                        return JsonResponse({
                            'response': bot_response,
                            'success': True
                        })
                    else:
                        logger.error("Invalid response structure from Gemini")
                        return JsonResponse({
                            'error': 'Invalid response format from Gemini'
                        }, status=500)
                else:
                    logger.error("No candidates in Gemini response")
                    return JsonResponse({
                        'error': 'No response generated by Gemini'
                    }, status=500)
                
            elif response.status_code == 400:
                logger.error(f"Gemini Bad Request: {response.text}")
                error_data = response.json() if response.content else {}
                error_message = error_data.get('error', {}).get('message', 'Bad request')
                
                if "API_KEY_INVALID" in error_message or "invalid" in error_message.lower():
                    return JsonResponse({
                        'error': 'ÔøΩ Invalid Gemini API key. Please check your API key in the .env file.'
                    }, status=401)
                else:
                    return JsonResponse({
                        'error': f'Bad request to Gemini: {error_message}'
                    }, status=400)
                    
            elif response.status_code == 403:
                logger.error("Gemini API Access Forbidden")
                return JsonResponse({
                    'error': 'üö´ Access forbidden. Please check your Gemini API key permissions.'
                }, status=403)
                
            elif response.status_code == 429:
                logger.error("Gemini Rate Limit Error")
                return JsonResponse({
                    'error': '‚è±Ô∏è Rate limit exceeded. Please try again later.'
                }, status=429)
                
            else:
                logger.error(f"Gemini API Error: {response.status_code} - {response.text}")
                error_data = response.json() if response.content else {}
                error_message = error_data.get('error', {}).get('message', 'Unknown error')
                
                return JsonResponse({
                    'error': f'Gemini API error: {error_message}'
                }, status=500)
                    
        except requests.exceptions.Timeout:
            logger.error("Request timeout")
            return JsonResponse({
                'error': 'Request timeout. Please try again.'
            }, status=408)
        except requests.exceptions.ConnectionError:
            logger.error("Connection error")
            return JsonResponse({
                'error': 'Connection error. Please check your internet connection.'
            }, status=503)
        except Exception as request_error:
            logger.error(f"Request Error: {str(request_error)}")
            return JsonResponse({
                'error': f'Request error: {str(request_error)}'
            }, status=500)
            
    except json.JSONDecodeError as json_error:
        logger.error(f"JSON Decode Error: {str(json_error)}")
        return JsonResponse({'error': 'Invalid JSON data'}, status=400)
    except Exception as e:
        logger.error(f"Unexpected Error: {str(e)}")
        return JsonResponse({
            'error': f'An unexpected error occurred: {str(e)}'
        }, status=500)
